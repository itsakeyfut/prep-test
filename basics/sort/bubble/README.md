# Bubble Sort

```rs
for i in 0..len {
    for j in 0..len - 1 - i {
        if nums[j] > nums[j + 1] {
            nums.swap(j, j + 1);
        }
    }
}
```

## ✅ それぞれの変数の意味

| 変数 | 役割                                                               |
| ---- | ------------------------------------------------------------------ |
| `i`  | 外側のループ（何周目かを表す）→ 後ろから確定済みの要素を除いていく |
| `j`  | 内側のループ（要素の隣と比較して並び替える）                       |

## なぜ len - 1 - i なの？

```rs
for j in 0..len - 1 - i
```

- `len - 1: nums[j]` と `nums[j+1]` を比較するので、最後のインデックス `j+1` が `len-1` を超えてはいけない。
- `- i`: 毎周ごとに一番大きい要素が右に確定していくので、比較の範囲を狭める。

## 例（10 個の要素なら）：

| i（周数） | j のループ範囲（比較対象） | 比較後に確定する最大要素     |
| --------- | -------------------------- | ---------------------------- |
| 0         | `0..8`（`9`個目と比較）    | 最後のインデックス（9 番目） |
| 1         | `0..7`                     | 8 番目に最大がくる           |
| 2         | `0..6`                     | 7 番目に最大がくる           |
| ...       | ...                        | ...                          |

→ 最後の i = `len - 1` で内側ループは `0..0` になり、比較が終了します。

## ✅ swap(j, j+1) の意味

```rs
if nums[j] > nums[j + 1] {
    nums.swap(j, j + 1);
}
```

- 隣り合う 2 つの値が逆順なら、入れ替える。
- これで大きい値がどんどん右に「浮かんでいく」＝バブルソートの由来です。

## 時間計算量・空間計算量

### 時間計算量（Time Complexity）

| ケース          | 時間計算量（比較回数） | 説明                                                                 |
| --------------- | ---------------------- | -------------------------------------------------------------------- |
| 最悪（Worst）   | `O(n²)`                | 配列が完全に逆順のとき。すべての要素を毎回比較・交換する必要がある。 |
| 平均（Average） | `O(n²)`                | ランダムな順序でも多数の比較と交換が必要。                           |
| 最良（Best）    | `O(n)`                 | 配列がすでにソートされているとき（最適化ありの場合のみ）。           |

### 空間計算量（Space Complexity）

| 空間計算量 | `O(1)` |
| ---------- | ------ |

- 定数メモリだけを使用します（配列を直接並び替えるインプレースソートなので）。
- 補助的な配列やデータ構造は使わない。
