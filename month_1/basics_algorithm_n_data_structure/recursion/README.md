# Recursion

## 🧠 なぜ重要？

- 再帰関数はアルゴリズムの世界で超重要
- 木構造探索（DFS）、組み合わせ探索（バックトラック）、DP（メモ化再帰）に不可欠。

Rust は関数呼び出しコストが小さいので、再帰との相性もいい。

ただし、所有権とライフタイムを意識する場面も出るので、慣れるのが大変。

## 🔥 まずは「再帰とは何か？」

- 関数の中で自分自身を呼び出すこと
- 小さな問題に分割して、最終的に答えを作り上げる

### 超単純な例：階乗（n!）

```rs
fn factorial(n: u32) -> u32 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn main() {
    println!("{}", factorial(5)); // 120
}
```

- `factorial(5)` → `5 * factorial(4)`
- `factorial(4)` → `4 * factorial(3)`
- ...
- `factorial(0)` → 1 ← これが終了条件

## 📜 再帰の設計 ＝ 2 本柱

1. Base Case (終了条件)を書く
   - 再帰が無限に続かないように「ここで止まる」という条件を最初に書く
2. Small Step (小さくする)
   - 問題を少しずつ小さくする（`n → n-1` など）

## 🪜 例題 1：Sum of Natural Numbers

「1 から n までの合計を再帰で求める」

```rs
fn factorial(n: u32) -> u32 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn sum(n: u32) -> u32 {
    if n == 0 {
        0
    } else {
        n + sum(n -1)
    }
}

fn main() {
    println!("{}", factorial(5)); // 120
    println!("{}", sum(5));       // 15
}
```

## 📚 Rust 特有のポイント

- 再帰は通常「コピー（Copy トレイト）」できる数値型（i32, u32 など）でやると楽
- 参照（&T）を使う場合、ライフタイム注釈が絡むことがある（今は気にしなすぎなく OK）。

## ⚠️ 注意：再帰の深さ制限（Rust では）

Rust スタックサイズが小さめなので

- あまりにも深い再帰（例：10 万回以上）はスタックオーバーフローになる可能性がある。

そのときは再帰をループに置き換える（末尾再帰最適化）か、手動スタックを使う。

## ✅ ここまでで理解すべきこと

- 「再帰は、問題を小さくして自分を呼び出す」
- 「終了条件を書かないと無限ループ」
- Rust では数値型が基本
- スタックオーバーフローに注意（深い探索では工夫する）
