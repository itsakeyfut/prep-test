# Indirect Recursion（間接再帰）

## ✅ 概要

関数 A が関数 B を呼び、関数 B がまた関数 A を呼ぶような再帰パターンです。
直接ではなく、複数の関数を通じて再帰が起こるため、「間接的再帰」と呼ばれます。

## 📘 例

```rs
fn f1(n: i32) {
    if n > 0 {
        println!("f1: {}", n);
        f2(n - 1);
    }
}

fn f2(n: i32) {
    if n > 0 {
        println!("f2: {}", n);
        f1(n / 2);
    }
}

fn main() {
    f1(20);
}

/*
 * f1: 20
 * f2: 19
 * f1: 9
 * f2: 8
 * f1: 4
 * f2: 3
 * f1: 1
*/
```

## 🔄 呼び出しの流れ（f1(20)）

```
f1(20) -> f2(19)
        -> f1(9)
           -> f2(8)
              -> f1(4)
                 -> f2(3)
                    -> f1(1)
                       -> f2(0) <- 終了
```

## 🤔 解説

- 状態の遷移が 2 つ以上の関数に分散される。
- 有限回で必ず終了することを保証するために、各関数で状態を少しずつ変化させることが必要。

## 🧠 設計視点

- 状態遷移に名前（関数）を付けて整理したいときに使う。
- オートマトン、マルチステートの状態機械などで理論的な意味を持つ
- Rust のように再帰に厳しい言語でも、間接再帰は柔軟に使える

## 🧪 演習：偶数か奇数かを間接再帰で判定（実用的ではないが例として）

```rs
fn is_even(n: u32) -> bool {
    if n == 0 {
        true
    } else {
        is_odd(n - 1)
    }
}

fn is_odd(n: u32) -> bool {
    if n == 0 {
        true
    } else {
        is_even(n - 1)
    }
}

fn main() {
    println!("{}", is_even(10)); // true
    println!("{}", is_even(9));  // true
}
```
