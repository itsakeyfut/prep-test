# Stack vs Heap Memory

## ✍️ 設計視点まとめ

まず**メモリの「置き場所」**について理解します。

| スタック（Stack）                                | ヒープ（Heap）                                  |
| :----------------------------------------------- | :---------------------------------------------- |
| 高速（超早い）                                   | 遅い（比較的遅い）                              |
| 小さい（サイズ制限あり）                         | 大きい（たくさん使える）                        |
| コンパイル時にサイズが決まっているものだけ置ける | 実行時にサイズが決まるものを動的に確保できる    |
| 使い終わったら自動で破棄される                   | 手動管理（Rust なら所有権とライフタイムで管理） |
| 例：関数の引数・ローカル変数・小さな配列など     | 例：Vec、Box、String など                       |

Rust でｈ

- スタックに置く
  - i32, f64, [T; N] (固定長配列)、小さな構造体など
- ヒープに置く
  - Vec<T>, String, Box<T>, Rc<T>, RefCell<T>

というイメージ

## 🧠 なぜこれが重要か？

- スタックは速いけど量に限りがある（だから巨大データはヒープに）
- ヒープは自由だけど借用・所有権に気を付ける
- Rust はこれをコンパイル時にしっかり管理してくれる（だから安全）

## 🛠️ Rust コードで確認してみよう！

```rs
fn main() {
    // スタック上のデータ
    let x = 5;
    let y = [1, 2, 3, 4, 5]; // 固定長配列もスタック

    // ヒープ上のデータ
    let v = vec![1, 2, 3, 4, 5]; // Vecはヒープ
    let s = String::from("Hello"); // Stringもヒープ

    println!("x: {}", x);
    println!("y: {:?}", y);
    println!("v: {:?}", v);
    println!("s: {}", s);
}
```

### ✅ ポイント

- x と y は「関数呼び出し終了時に自動的に破棄」
- v と s は「ヒープに確保 → 所有権が生きてる間だけ有効」

Rust はこれをコンパイル時に保証するので、メモリバグが起きない。

## ✅ ここまでで理解すべきこと

- スタックは「高速 & 小型 & 自動解放」
- ヒープは「大容量 & 動的 & 所有権管理」
- Rust はこれを「コンパイル時に安全に管理してくれる」
