## アイデア

基の数値 `x` を 10 で割りながら各桁を末尾から `reversed` に追加していく。

たとえば `x = 121` なら、 reversed に `1 → 12 → 121` と構築されていく

■ こうやれば解けそう
数値 x を逆から一桁ずつ取り出して新しい数 reversed を作る。

それを元の数 x と比較して、一致すれば回文である。

ただし：

- 負の数は回文になり得ない
- 末尾が 0 の数は、0 から始まる数が存在しないため、0 以外の数では回文にはなり得ない。

■ ステップ
x が負の場合は false を返す
→ -121 は回文ではない。

x の末尾が 0 かつ x が 0 でない場合も false を返す
→ 例えば 10 は回文ではない（"01" は先頭が 0）。

reversed（反転した数）を 0 で初期化する

x が reversed より大きい間はループを回す
→ 反転途中で止めて、半分だけ比較すれば十分（後述）

反転の 1 ステップはこう：

reversed = reversed \* 10 + x % 10

x = x / 10（整数除算）

ループ終了後、x == reversed または x == reversed / 10 なら true

奇数桁の時、真ん中の数字は無視できるため、reversed / 10 との比較でも良い

## 数値計算

これは「x の末尾の桁を reversed に加える」処理です。

```rs
reversed = reversed * 10 + x % 10
```

1 回目：

- x = 123
- reversed = 0

```
x % 10 = 3          // xの末尾の桁を取り出す
reversed = 0 * 10 + 3 = 3
x = x / 10 = 12     // 最後の桁を取り除く
```

2 回目：

```
x % 10 = 2
reversed = 3 * 10 + 2 = 32
x = 12 / 10 = 1
```

3 回目：

```
x % 10 = 1
reversed = 32 * 10 + 1 = 321
x = 1 / 10 = 0
```

最終的に：

x = 0

reversed = 321

つまり、元の 123 を逆順にした 321 が得られました！
