> Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed.
> Then return the number of elements in `nums` which are not equal to `val`.
>
> Consider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:

- Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.
- Return `k`

Custom Judge:

The judge will test your solution with the following code:

```rs
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

If all assertions pass, then your solution will be accepted.

> 整数配列 `nums` と整数 `val` が与えられたとき、`nums` 内の `val` のすべての出現をインプレースで削除してください。
> 要素の順序は変更されても構いません。
> その後、`val` とは異なる値の要素の個数を返してください。
>
> `val` とは異なる値の要素の個数を `k` とすると、解答が正しく受理されるためには、以下の条件を満たす必要があります：

- 配列 `nums` を変更し、最初の `k` 要素が `val` とは異なる要素になるようにしてください。
- `nums` の残りの要素やサイズは重要ではありません。
- `k` を返してください。

カスタムジャッジ（テスト方式）：
ジャッジは次のコードを使ってあなたの解答をテストします：

```rs
int[] nums = [...]; // 入力配列
int val = ...; // 削除対象の値
int[] expectedNums = [...]; // 正しい出力（長さが一致し、val を含まない）
                            // 並べ替えられていると仮定

int k = removeElement(nums, val); // あなたの実装を呼び出す

assert k == expectedNums.length;
sort(nums, 0, k); // nums の先頭 k 個をソート
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

すべてのアサーションが通れば、あなたの解答は正しいと判定されます。
