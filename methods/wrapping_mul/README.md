# wrapping_mul

wrapping_mul は、オーバーフローしてもパニックにならず、値をラップアラウンド（巻き戻し）して計算を続ける掛け算です。

wrapping_mul の特徴：

- オーバーフローが発生してもパニックにならない
- 結果は「下位ビットに巻き戻された値」となる（2 の補数表現に基づく）

## 例：

```rs
fn main() {
    let a: u32 = 1_000_000;
    let b: u32 = 5_000;

    let result = a.wrapping_mul(b);

    println!("{}", result); // 705032704
}
```

この例では、`1_000_000 * 5_000 = 5_000_000_000` は `u32` の最大値（4_294_967_295）を超えるため、オーバーフローしますが、

- `wrapping_mul` はそのままビットを切り詰めて、
- ラップアラウンドされた（予測できる）値を返します。

## 注意点

wrapping_mul は「オーバーフローしてもいい（むしろそれを利用する）」場合に使います。
例えば、暗号処理やローリング ID などの場面で利用されます。
